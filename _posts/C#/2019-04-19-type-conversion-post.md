---
layout: post
title:  "C# Fragment : Type Conversion"
date:   2019-04-19
excerpt: "NULL"
tag:
- C#
- Type Conversion
---

# 什么是转换

转换是接受一个类型的值并使用它作为另一个类型的等价值的过程。转换后值等价，类型为目标类型。

# 转换的分类

## 一般转换

从转换的方式来看，可以分为**显式转换**和**隐式转换**。显示和隐式最主要的区分点在于，这种转换是否让这个“值”的描述更加“精确”，如果是，那么则是显示转换，否则为隐式转换。例如：玫瑰是植物。如果我们需要更精确地指出玫瑰是一种花，那么我们就需要显式地强调“玫瑰是花的一种”。反过来，玫瑰是花，而花是植物是已知的，这时候我们便不需要特别说明玫瑰是植物了，因为此时它已经包含了这一信息。

一般来说，在不丢失数据的情况下，语言会自动进行预定义对象类型的转换，这种转换称为预定义的隐式转换。对于数字类型雷说，例子即为把`int`类型的数字10转换为`double`类型；相对地，在可能发生数据丢失的场合，语言并不会为我们自动进行转换，这时，我们需要做显式转换。

```c#
// 显式转换例子
ushort a = 100;
ushort b = 600;
byte c = (byte)a;
byte d = (byte)b;
```

`ushort`类型的表示范围是0~2^16^-1，而`byte`类型的表示范围只有0~2^8^-1。此时则需要进行显式转换。在上面的例子中，`a`可以被安全地转换为`byte`类型的`c`,但是对于`d`来说，由于`b`的值超过了`byte`的表示范围，在转换过程中则会进行高位截断，也就是说，`ushort`超出`byte`的八个高位数值会被忽略，转换后，`d`的值为600 % 128 = 88。

对于引用类型，由于所有的类都继承了`Object`，所以都可以被隐式转换为`Object`类型，类似地，类引用也可以转换为继承链中的任意类引用以及它实现的所有接口引用。引用的显式转换则发生在从基类到派生类的过程中，前提是这个转换不会编译错误，或者说抛出异常。

## 装箱、拆箱

基于面向对象，还有一种特殊的转换，**装箱**和**拆箱**转换。

在C#中，所有的类型都派生自`Object`类型，包括值类型。值类型是高效轻量的类型，他们在堆上存在时并不会包括它所属的对象组件。当我们需要使用这个对象时，我们就会根据这个值组装为一个完整的对象，也就是装箱。装箱也是一种隐式转换，它接受值类型，并根据这个值在堆上创建一个完整对象并返回引用。装箱操作返回的并不是原值的引用，而是一个根据原值组装的对象的副本。

```C#
int number = 0;
object obj = number; // 这里隐式地进行了装箱操作
number = 1;
obj = 2; // 此时number的值仍是1；obj中的值只是一个副本，在它身上做的修改不会反馈到原对象上
```

对应地，拆箱则是把装箱后的对象转换回值类型的过程。拆箱是显式转换。

```C#
int number = 0;
object obj = number; // 先把number装箱
int number2 = (int)obj; // 显式进行拆箱
// 此时，number、obj、number2对应的值均为0
```

拆箱的操作结果只能是原始类型，否则会抛出异常。

## 自定义转换

从转换的定义者来看，还可以分为预定义转换和自定义转换。这个比较容易理解，语言本身帮我们进行的称为预定义转换，其余则是自定义转换。

```C#
// 一个例子
public class A {
    public int num;
    public A(int _num) {
        num = _num;
    }
    // 在C#中，转换是静态方法
    // implicit/explicit分别代表隐/显式
    public static implicit operator int(A a) {
        return a.num;
    }
    public static implicit operator A(int _num) {
        return new A(_num);
    }
}
```

自定义的类型转换有以下规则：

1. 不能重定义标准的转换
2. 转换必须以类或结构为单位
3. 转换源和目标类型必须不同
4. 对于同源同目标的转换，不可以同时声明其显隐式
5. 转换操作符必须是源或目标的成员
6. 源类型和目标类型不能互为继承关系（标准一的细化）
7. 源类型和目标类型均不能为接口或者`Object`类型（标准一的细化）

# 转换的保障

## is运算符

通过前面的学习，我们知道了有些转换请求时不成功的，并在运行时抛出异常，这是我们不希望看到的。`is`运算符可以帮我们确认转换的成功与否。

```C#
if (ExpressionA is ExpressionB) {
    // Do type conversion
}
```

`is`运算符返回值为`bool`，当`ExpressionA`的返回值可以被成功转换为`ExpressionB`的返回值时返回`true`，但是`is`的检查只适用于引用转换、装箱、拆箱，并不支持自定义转换。

## as运算符

`as`运算符则是强化版强制转换，并且不会抛出异常，而是在转换失败时返回`null`。

```c#
destinationTypeInstance = sourceTypeInstance as DestinationType;
if (destinationTypeInstance != null) {
    // Do something
}
```

注意到，`as`运算符返回的是引用类型，也就是说，我们可以将其作为赋值运算的右值，而`DestinationType`则必须为引用类型。