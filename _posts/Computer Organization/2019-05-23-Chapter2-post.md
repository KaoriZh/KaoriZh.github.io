---
layout: post
title:  "Computer Organization-Chapter2：Data at the Machine Level"
date:   2019-05-23
excerpt: ""
tag:
- Computer Organization
---

# Chapter  2.数据的机器层次表示

## 2.1数值数据的表示

### 表示方法

真值：用+、-号加绝对值表示数值的大小，计算机无法识别

原码：最高位为符号位，0正1负，其他部分与真值相同

反码：最高位为符号位，0正1负，数值部分，正数与真值相同，负数按位取反

补码：最高位为符号位，0正1负，数值部分，正数与真值相同，负数按位取反并+1

### 码制转换

原码->补码：

正数：补码 = 原码 = 真值

负数：补码 = 原码除符号位的数按位取反+1 = 原码自低向高位位数第一个1以及右部的0保持不变，符号位不变，其余按位取反

### 原码、反码、补码的比较

1.最高位都表示符号，补码和反码符号位可以看作数值的一部分，一起参与运算，但原码必须分开处理。

2.补码有唯一的0的表示形式：0000，原码的0为0000和1000，反码为0000和1111。

3.原码反码表示的正负数范围对称，补码负数范围比正数多1个。



## 2.2机器数的定点表示与浮点表示

### 2.2.1定点表示

所有数据的小数点位置固定不变（在符号位与数值之间或者位于数值之后，分别对应定点小数（纯小数）和整数），且小数点是隐含表示的，不占用位。现代计算机一般采用浮点方式表示小数。

### 2.2.2浮点表示

让小数点的位置根据需要浮动。
$$
N=M\times r^E
$$
N为真值，M为尾数，E是阶码，r是底数。尾数一般为纯小数，常用原码或补码表示；阶码为纯整数，常用移码或补码表示。

![Floating-point.png](https://github.com/KaoriZh/KaoriZh.github.io/blob/master/_Images/Computer%20Organization/Floating-point.png?raw=true)

#### 规格化的浮点数

即浮点数的科学计数法。为了提高运算的精度，充分利用位数的有效数位，浮点数通常表示为规格化形式。

例：对于二进制数0.0001101，可以表示为
$$
0.001101\times 2^{-01}，0.01101\times 2^{-10}，0.1101\times 2^{-11}
$$
其中，最后一个才是规格化的浮点表示，即尾数的最高位必须是有效值。

#### 溢出

数值大于所能表示的最大正数称为正上溢，小于所能表示的绝对值最大负数称为负上溢，数据产生上溢时应停止运算操作进行溢出处理。数值位于0到规格化最小正数之间称为正下溢，位于0到规格化绝对值最小负数之间称为负下溢，产生下溢时计算机一般不做处理，将数值置为机器零即可。

### 2.2.3移码表示法

**浮点数阶码是带符号的定点整数，通常采用移码表示。**

#### 定义

移码（增码、偏码）：在真值X基础上加一个常数（称为偏置值），相当于X在数轴上向正方向偏移了若干单位。

例：X = 1101101，偏置值为2^7。
$$
[X]_移=2^7+(1101101)_2={\bf{1}}1101101，[X]_补={\bf{0}}1101101
$$
X=-1101101，偏置值为2^7。
$$
[X]_移=2^7+(-1101101)_2=10000000-1101101={\bf{0}}0010011，[X]_补={\bf{1}}0010011
$$

#### 特点

1.移码的符号位（最高位）为0负1正，与另外三种码制相反。

2.移码可以直观反应真值的大小，全为0时真值最小，全为1时真值最大，有助于浮点数阶码的大小比较。

3.移码0的表示形式唯一：1000。

4.移码把真值映射到正数域，即移码可视为无符号数，可以按无符号数规则比较大小。

5.同一数值的移码和补码除最高位相反外，其他各位相同。

#### 浮点数阶码采用移码表示的原因

1.便于比较，由于规定了规格化表示，阶码的大小可以反应浮点值的大小。

2.阶码全为0时，尾数也全为0，简化机器的判零电路。

### 2.2.4浮点数尾数的基数

基数r越大表示范围越大，精度越小，运算中精度损失越小，运算中的移位次数越少（运算速度越高）。

### 2.2.5IEEE754标准浮点数

目前常用的80x86系列微型机采用的标准，第一位为数符，中间若干位为移码表示的阶码，余下的部分是原码表示的尾数。下表是IEEE754标准中的3种浮点数。

|    类型    | 数符（位） | 阶码（位） | 尾数（位） | 总位数 | 偏置值（16进制/10进制） |
| :--------: | :--------: | :--------: | :--------: | :----: | :---------------------: |
|  短浮点数  |     1      |     8      |     23     |   32   |    7FH / 127(2^8-1)     |
|  长浮点数  |     1      |     11     |     52     |   64   |       3FFH / 1023       |
| 临时浮点数 |     1      |     15     |     64     |   80   | 3FFFH / 16383（2^14-1） |

短浮点数和长浮点数又分别称为单精度和高精度浮点数，它们都隐含了尾数的最高数位（以2为基数的规格化浮点数的尾数恒为1，故隐含），临时浮点数又称扩展精度浮点数，它没有隐含位。

例：十进制数100.25转换成短浮点数。
$$
（100.25）_{10}=(1100100.01)_2=(1.10010001)_2\times 2^{(110)_2}
$$

$$
符号位为0
$$

$$
阶码的移码为111,1111+110=1000,0101
$$

$$
尾数为100,1000,1000,0000,0000,0000
$$

短浮点数C1C90000H转换成十进制数。
$$
(C1C90000)_{16}=(1100,0001,1100,1001,0000,0000,0000,0000)_2
$$

$$
符号位为1
$$

$$
阶码的移码为1000,0011，减去偏置值，阶码真值：1000,0011-111,1111=100
$$

$$
尾数为100,1001,0000,0000,0000,0000，即(1.1001001)_2
$$

$$
规格化形式为(1.1001001)_2\times 2^{(100)_2}，即(11001.001)_2=(25.125)_{10}
$$

$$
加上符号位，该数的十进制表示为-25.125
$$

### 2.26定点、浮点表示法的区别（字长相同情况下）

1.数值范围：浮点远大于定点。

2.精度：浮点的表示范围大是以牺牲精度为前提的。

3.运算：浮点运算要复杂许多。

4.溢出处理：定点数为普通溢出，浮点数只有在尾数和阶码都超出表示范围时才溢出。

## 2.3非数值数据的表示

#### 2.3.1字符和字符串的表示

1.ASCII字符编码：每字符8位，最高位为奇偶校验位，其余七位为码值。

2.汉字国标码（汉字交换码，GB码）：规定每个汉字或图形字符都用两个字节表示，每个字节只用低7位编码，最多可表示128 * 128 = 16384个字符。

3.汉字区位码：将国标码GB2312-80中的6763个汉字分为94个区，每个区包含94个字，区位码定长4位，前两位为区码，后两位为位号。

4.汉字机内码：两字节长，解决国标码和ASCII码产生歧义的问题。机内码 = 国标码 + 8080H。

5.汉字字形码：点阵表示汉字。

### 2.3.3统一代码

统一代码即Unicode，用两字节（16位二进制数）表示每个符号，容量为65536.Unicode的实现方式称为Unicode转换格式（Unicode Translation Format，UTF）。

> UTF-8是一种变长编码。UTF-16采用定长（两字节）存储，但无法兼容ASCII。



## 2.4十进制数和数串的表示

### 2.4.1十进制数的编码

BCD码（Binary Code Decimal，二进制编码的十进制数）：4位二进制数组合出16种代码，使用其中10种状态即可表示数字0~9。由于16种状态并没有被全部使用，BCD码也有多种。下面是常见的几种BCD码。

| 十进制数 | 8421码 | 2421码 | 余3码 | Gray码 |
| :------: | :----: | :----: | :---: | :----: |
|    0     |  0000  |  0000  | 0011  |  0000  |
|    1     |  0001  |  0001  | 0100  |  0001  |
|    2     |  0010  |  0010  | 0101  |  0011  |
|    3     |  0011  |  0011  | 0110  |  0010  |
|    4     |  0100  |  0100  | 0111  |  0110  |
|    5     |  0101  |  1011  | 1000  |  1110  |
|    6     |  0110  |  1100  | 1001  |  1010  |
|    7     |  0111  |  1101  | 1010  |  1011  |
|    8     |  1000  |  1110  | 1011  |  1001  |
|    9     |  1001  |  1111  | 1100  |  1000  |

#### 8421码

即自然码，各个数位的权值分别为8、4、2、1，不能和二进制表示数混淆。例：十进制数39，8421码为0011,1001，二进制值为100111B。

#### 2421码

各个数位权值分别为2、4、2、1，它是对9的自补码。3即0011，6即1100，两数互为位取反关系。十进制运算中采用自补码可以简化电路。不允许出现0101~1010，这些是非法码。

#### 余3码

无权码，是在8421码基础上加3（0011）得到码值，也是一种对9的自补码，不允许出现0000~0010和1101~1111，这些事非法码。

#### Gray（格雷）码

格雷码方案很多。优点：可以避免计数发生中间错误，因而也被称为可靠性编码。无权码，变化到相邻的值时只有一个二进制位状态改变，首尾两个数的Gray码也只有一个位不同，因而也称为循环码。6个非法码视方案而定。

### 2.4.2十进制数串

#### 1.非压缩的十进制数串

即对单个数进行BCD编码后拼接成的串，一个字节存放一个十进制数或符号的ASCII码。一个数串占用连续的多个字节。主要应用于非数值的处理，不便于计算。

#### 2.压缩的十进制数串

一个字节存放两个十进制数，节省空间，方便计算。一个压缩的十进制数串占用连续多个字节，每个数字占用半个字节，常用8421码表示，符号位占用半个字节，存放在最低数值位之后，通常用CH表示正，DH表示负。规定数字个数与符号位之和要为偶数，和为奇数时在最高值位之前补0（0000）。

例：+123表示为0001,0010,0011,1100；-2648表示为0000,0010,0110,0100,1000,1101。



## 2.5不同类型的数据表示

### 2.5.1C语言中的数据表示

float、double对应IEEE754的单精度浮点数和双精度浮点数，范围分别为3.4x10^-38~3.4x10^38和1.7x10^-308~1.7x10^308。

short和int为16位，long为32位。

### 2.5.2现代微型计算机系统中的数据表示

IA（Intel Architecture）-32结构，基本类型：字节、字、双字（DWORD）、四字（QWORD）、双四字（DQWORD），分别为1、2、4、8、16字节。



## 2.6数据校验码

数据在存取和传送过程中可能会发生错误，数据校验码是指那些能够发现错误或能够自动纠正错误的数据编码，又称为检错纠错码。任意两个码字之间变化所需改变的最少位数称为数据校验码的码距，如：8421码的0000与0001转换仅需变动一位，故码距为1，码距为1的编码没有检错能力。码距越大，检错纠错能力越强，且检错能力总是大于等于纠错能力。

具有检错纠错能力的原理：在编码中，除去合法的码字外，再加进一些非法的码字，当某个码字出错时就会变为非法码字。合理安排非法码字数量和编码规则即可达到纠错目的。

### 2.6.1奇偶校验码

最简单的数据校验码，码距为2。可以检测一位（或奇数个位）错误，但无法确定出错位置。这种方式检错能力低，但是应用最广泛，常用于存储器读写检查或ASCII字符传送检查。

实现方法：奇（偶）校验即校验位的取值使整个校验码中1的个数为奇（偶）数，校验位为新增一位作为最高位。通常采用奇校验，奇校验不会出现全0码，便于判别。奇校验结果取反即偶校验结果。

| 有效信息（8位） | 奇校验码（9位） | 偶校验码（9位） |
| :-------------: | :-------------: | :-------------: |
|    0000,0000    |   1,0000,0000   |   0,0000,0000   |
|    0101,0100    |   0,0101,0100   |   1,0101,0100   |
|    0111,1111    |   0,0111,1111   |   1,0111,1111   |
|    1111,1111    |   1,1111,1111   |   0,1111,1111   |

校验检测：在生成校验位之后，将9个数（8位信息位和1位奇偶校验位）送入检测电路，若读出代码无错，则“校验出错”输出0，否则输出1。
$$
S_{偶校验出错}=P_校 \bigoplus D_1 \bigoplus D_2 \bigoplus D_3 \bigoplus D_4 \bigoplus D_5 \bigoplus D_6 \bigoplus D_7 \bigoplus D_8
$$


> 交叉奇偶校验：进行大量字节传送时，每字节横向校验，全部字节的同一位纵向校验，横校验无法检出的错误大概率会被纵校验检测出，从而降低错判概率。

### 2.6.2汉明校验码

Richard Hamming于1950年提出，目前广泛采用的一种有效的校验码。主存的ECC（Error Correcting Code，错误检查与纠正）就是采用类似的技术。实质上是多重奇偶校验。

实现原理：在有效信息位中加入几个校验位，均匀拉大码距，将某一位的错误映射到几个校验位上，从而指出错误位置，便于自动纠错。校验位数K和信息位数N的关系为：
$$
2^{K-1}\geq N+K+1
$$
例：对一个字节（8位）的数据进行汉明码编码。

步骤：

1.首先根据公式得出此时K=5，即总位数为13。记最高位位号为13，最低位为1（左高右低）。对于每个汉明码i（编号1~5），分配的位号为2^(i-1)，若超过最高位号，则分配为最高位，其余为信息位。
$$
P为校验位，D为信息位，则海明码可以表示为P_5D_8D_7D_6D_5P_4D_4D_3D_2P_3D_1P_2P_1
$$

$$
对应的编号为H_{13}H_{12}H_{11}H_{10}H_{9}H_{8}H_{7}H_{6}H_{5}H_{4}H_{3}H_{2}H_{1}
$$

2.为方便描述，对单个校验码采用偶校验，被检验的每一位位号等于校验它的各校验位的位号之和，即汉明码的位号实质上是参与校验的各校验位权值之和。
$$
如：第一个信息位D_1，对应H_3，3即1+2，也就是说，D_1位对应的校验位为P_1和P_2；
$$

$$
第七个信息位D_7，对应H_{11}，11即8+2+1，对应校验位为P_8、P_2和P_1。
$$

由此可以得出以下校验位的组成：
$$
P_1=D_1 \bigoplus D_2 \bigoplus D_4 \bigoplus D_5 \bigoplus D_7
$$

$$
P_2=D_1 \bigoplus D_3 \bigoplus D_4 \bigoplus D_6 \bigoplus D_7
$$

$$
P_3=D_2 \bigoplus D_3 \bigoplus D_4 \bigoplus D_8
$$

$$
P_4=D_5 \bigoplus D_6 \bigoplus D_7 \bigoplus D_8
$$

 补充第五个校验位使得每一个数据项都在校验位中出现相同次数：
$$
P_5=D_1 \bigoplus D_2 \bigoplus D_3 \bigoplus D_5 \bigoplus D_6 \bigoplus D_8
$$
现在，每个信息位在校验位中都出现了3次，即每个信息位发生变化时，必有3个校验位发生变化，即码距为4。

### 2.6.3循环冗余校验码

#### 1.编码方法

Cyclic Redundancy Check（CRC），在计算机网络、同步通信和磁表面存储器中广泛使用的一种校验码。

实现方法：通过除法建立信息位和校验位之间的关系，有效信息用多项式M（X）表示，将M（X）左移若干位，校验式为G（X），M（X）除以G（X），得到的余数多项式R（X）就是校验式。有效信息和校验位拼接构成CRC码。

编码方法：左为信息位，右为校验位，若信息位数为N，校验位数为K，则该码称为（N+K，N）码。

![CRC](https://raw.githubusercontent.com/KaoriZh/KaoriZh.github.io/master/_Images/Computer%20Organization/CRC.png)

  步骤：

1.把待编码的N位有效信息表示为多项式M（X）。

2.把M（X）左移K位，得到M（X）*X^K，空出的K位留给K位余数。

3.选取一个K+1位的多项式G（X），对M（X）*X^K做除（mod 2）。
$$
{M(X)\times X^K\over G(X)}=Q(X)+{R(X)\over G(X)}
$$
4.把左移K位以后的有效信息与余数R（X）作加减（mod 2），拼接为共N+K位的CRC码。

例：选择产生多项式G（X）=1011，把4位有效信息1100编成CRC码。
$$
M(X)=X^3+X^2=1100
$$

$$
M(X)\times X^3=X^6+X^5=110,0000（即左移3位）
$$

$$
G(X)=X^3+X+1=1011
$$

$$
{M(X)\times X^3\over G(X)}={110,0000\over 1011}={010\over 1011}（模2下除法）
$$

$$
M(X)\times X^3+R(X)=110,0000+010=110,0010
$$

得到所求的CRC码为1100010，这是一个（7，4）码。

**模2运算是一种二进制算法，不考虑进位借位。模2加减法等同于按位异或；模2乘法类似与普通乘法，但在处理累加进位结果时采用模2加法法则；模2除法确定商时采用模2减法法则，不带借位，余数通过异或得到，若余数全0则商0，否则商1。**

![Division Modulus 2](https://raw.githubusercontent.com/KaoriZh/KaoriZh.github.io/master/_Images/Computer%20Organization/Division%20Modulus%202.png)

#### 2.校验与纠错

CRC码被接收后，再次用G（X）去除，得到的余数为0则说明代码正确，否则表明某一位出错，然后由余数值确定出错位置。

|       码值        | 余数 | 出错位 |
| :---------------: | :--: | :----: |
| 1100010（正确码） | 000  |   无   |
|      1100011      | 001  |   7    |
|      1100000      | 010  |   6    |
|      1100110      | 100  |   5    |
|      1101010      | 011  |   4    |
|      1110010      | 110  |   3    |
|      1000010      | 111  |   2    |
|      0100010      | 101  |   1    |

假设出错，那么余数不为零，查表可得余数对应的出错位。对余数补0后继续进行除法，可得到下一个余数。（如：当余数为011，即出错位为4时，余数补0后为0110，用1011继续进行模2除法，可得余数110）继续进行除法直到把出错位移至最高位（在（7，4）码中对应第七位，最右边为第0位），然后通过异或门将最高位取反纠正。（出错位为x，对应做x次补0除法即可把出错位左移至最高位）

#### 3.生成多项式G（X）的选择标准

（1）任意错误计算的余数均不能为0。

（2）不同位的错误对应不同的余数。

（3）对余数作模2除法应使余数循环。

#### 4.常用的生成多项式

$$
G(X)=X^{16}+X^{15}+X^2+1
$$

$$
G(X)=X^{16}+X^{12}+X^6+1
$$

